method 1
1 3 2 4 2 
using hashmp
find frequency of all element 
then find which element has more than 1 frequency

    unordered_map<int,int> mpp;
        for(auto i : nums){
            mpp[i]++;
        }
        int ans;
        for(auto it : mpp){
            if(it.second > 1){
                ans = it.first;
                break;
            }
        }
        return ans;

method 2 ------------------------------------------

Only one duplicate.

Numbers are between 1 and n.
This swapping will always lead you to the duplicate number due to the cycle in index mapping.

while(nums[0] != nums[nums[0]])
swap(nums[0],nums[nums[0]]

return nums[0];

as all the number is between 1 to n then akdin na akdin thik milbe as we also swaping
